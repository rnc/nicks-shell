# -*- sh -*-
#
#
# Shell independent (bash/zsh) set of common variables/functions.
#

#################
### Variables ###
#################

[[ $PATH != *"$HOME/bin"* ]] && PATH=$PATH:$HOME/bin

# Note: this may need changing for F26 : https://fedoraproject.org/wiki/Changes/KerberosKCMCache
if ! grep -q "default_ccache_name" /etc/krb5.conf
then
    # Force location on machines without persistent cache for Kerberos cache. Useful to workaround problems with puddle generation.
    KRB5CCNAME=/tmp/"$USER"_ccache
fi
# Ensure any Python virtualenv that installs certifi doesn't clash and we use the system certificates
export REQUESTS_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt


# https://github.com/keybase/keybase-issues/issues/2798 ; https://issues.apache.org/jira/browse/MGPG-59
GPG_TTY=$(tty)

# https://unix.stackexchange.com/questions/258679/why-is-ls-suddenly-wrapping-items-with-spaces-in-single-quotes
# Rather than setting every ls alias just force it with:
QUOTING_STYLE=literal

# https://forum.manjaro.org/t/kde-plasma-related-error-messages-in-journal/21790
QT_LOGGING_RULES='*=false'

[[ -z $EDITOR ]] && EDITOR="emacs -nw --no-init-file --no-site-file"

SVN_EDITOR="$EDITOR"

# https://github.com/trapd00r/LS_COLORS
if [ -d $NS_PREFIX/LS_COLORS ]
then
    eval $( dircolors -b $NS_PREFIX/LS_COLORS/LS_COLORS )
fi

export PATH EDITOR SVN_EDITOR KRB5CCNAME GPG_TTY QUOTING_STYLE QT_LOGGING_RULES
export JAVA_HOME=`dirname $(dirname $(readlink -f $(which java)))`
export QUAY_USERNAME=ncross

# https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux
# https://misc.flogisoft.com/bash/tip_colors_and_formatting
if tput setaf 0 &>/dev/null
then
    OFF="\e[0m"
    # Equivalent to $(tput bold)
    BOLD="\e[1m"
    # Equivalent to $(tput setaf 1)
    RED="\e[31m"
    # Equivalent to $(tput setaf 2)
    GREEN="\e[32m"
    # Equivalent to $(tput setaf 3)
    YELLOW="\e[33m"
    # Equivalent to $(tput setaf 4)
    BLUE="\e[34m"
    # Equivalent to $(tput setaf 7)
    WHITE="\e[37m"
fi
ERROR="${BOLD}${RED}%s${OFF}\n"
INFO="${BOLD}${GREEN}%s${OFF}\n"

#################
### Functions ###
#################

# Note - unset NO_LOCAL_OPTIONS from .zshrc as using LOCAL_OPTIONS in
# below functions to override .zshrc options temporarily. Also tried
# resetting zsh to known default using emulate -L zsh but my nested
# function calls don't work correctly then.

if [ "$SHELL" = "/bin/bash" ] || [ "$SHELL" = "/usr/bin/bash" ]
then
    # If we are a bash shell define noop function to work around zsh specific calls.
    function setopt ()
    {
        :
    }
fi
git -c core.pager="less" >& /dev/null
[[ "$?" == "129" ]] && GIT_NOCMDCONFIG=true



# Translates a group:artifact:id to a format that httpie / DA accepts
# Use with http e.g.
# http POST http://<url>/da/rest/v-1/reports/lookup/gavs
#   [ versionSuffix=temporary-redhat repositoryGroup=DA-temporary-builds ]
#   "gavs:=$(gav com.fasterxml.jackson.core:jackson-databind:2.9.9)" | jq ".[].bestMatchVersion"
function gav()
{
    [[ -z "$1" ]] && printf "$ERROR" "Specify-the-gav" && return 1
    echo $1 | awk '{split($0, a, ":"); print "[{\"groupId\":\""a[1]"\",\"artifactId\":\""a[2]"\",\"version\":\""a[3]"\"}]" }'
}

# Displays a syntax highlighted file in the terminal
function f()
{
    which highlight >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Install highlight" && return 1
    [[ $# = 0 ]] && echo "Pass in file" && return 1

    local EXTRA=""
    local LINENUM="--line-numbers"
    while [[ $# -ne 1 ]]
    do
        if [ "$1" = "-n" ] # No line numbers
        then
            LINENUM=""
        else
            EXTRA=$1
        fi
        shift
    done

    [[ ! -f "$1" ]] && echo "No such file \"$1\"" && return 1

    local extension=$(echo $(basename $1) | awk -F . '{print $NF}')
    local SYNTAX

    case $extension in
      "pom")
        SYNTAX="--syntax=xml"
        ;;
      "cfg")
        SYNTAX="--syntax=conf"
        ;;
      ".properties")
        SYNTAX="--syntax=ini"
        ;;
      ".log")
        SYNTAX="--syntax=txt"
        ;;
      *)
        local h=$(head -n 1 $1)
        if [[ "$h" = "# -*- sh -*-" ]] || [[ "$h" = "# -*- bash -*-" ]] || [[ "$h" = "# -*- zsh -*-" ]]
        then
            SYNTAX="--syntax=sh"
        elif [[ ! $extension =~ ^($(highlight --list-scripts=langs | grep -E -v /usr/share | tr -d '()'| grep -E '.*[a-zA-Z]+.*:.*[a-zA-Z]+.*' | cut -f2 -d':' | tr -s [:space:] '|'))$ ]]
        then
            # Complete fallback to text
            SYNTAX="--syntax=txt"
        fi
    esac

    highlight $LINENUM --validate-input --style=zenburn --plug-in=java_library $EXTRA $SYNTAX -O xterm256 $1 | less -R
}

# Generates a complex password and inserts it into the clipboard
function getpasswd()
{
    which pwgen >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Install pwgen" && return 1
    which xclip >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Install xclip" && return 1

    local SELECTION=p
    local SYMBOLS=y
    while [ -n "$1" ]
    do
        case "$1" in
          -c)
            shift
            SELECTION=c
            ;;
          -s)
            shift
            SYMBOLS=
            ;;
          -h)
            echo "Usage is $0 [ -s : Don't include symbols in the password || -h || -c : Use X selection XA_CLIPBOARD as opposed to XA_PRIMARY.\n\tFormer allows Ctrl-V paste, latter allows middle mouse button paste. ]"
            return 1
            ;;
          *)
            break;
        esac
    done

    pwgen -scn"$SYMBOLS" 32 1 | xclip -selection $SELECTION
}

function getip()
{
    ip route get 1 | head -1 | awk '{print $7}'
}

# If we are printing the environment (no arguments) print it sorted.
function env()
{
    if [ $# == 0 ]
    then
        /usr/bin/env | env "LC_ALL=C" sort
    else
        /usr/bin/env "$@"
    fi
}


# Coloured manpages. An alternative using lynx is 'man -Hlynx less'
function man() {
    env \
        LESS_TERMCAP_mb=$'\E[01;31m' \
        LESS_TERMCAP_md=$'\E[01;38;5;74m' \
        LESS_TERMCAP_me=$'\E[0m' \
        LESS_TERMCAP_se=$'\E[0m' \
        LESS_TERMCAP_so=$'\E[38;5;246m' \
        LESS_TERMCAP_ue=$'\E[0m' \
        LESS_TERMCAP_us=$'\E[04;38;5;146m' \
        GROFF_NO_SGR=yes \
        man "$@"
}

# Note: while this does create a tunnel by default, it uses a different local port (18080)
# to avoid clashing with any local processes.
#
# It is recommended to store in your $HOME/.ssh/config your entries as per e.g.
#
#    Host <alias-name>
#       HostName <real-host-name>
#       User <user-name>
#       IdentityFile <RSA pub file>
#
function ssh()
{
    # Attempt to find a free local port to use.
    local myport
    local -a ports
    ports=(18080 18081 18082 18083 18084 18085 18086 18087 18088 18089 18090 18091 18092 18093 18094 18095 18096 18097 18098 18099 18100)
    for myport in ${ports[@]}; do
        lsof -i -n -P | grep LISTEN | grep -q ":${myport}"
        [ "$?" -eq 1 ] && break
    done
    echo "Using forwarding port $myport"

    # Default to also creating a SSH tunnnel as well. Useful if we are doing smoke testing
    # and we need to see the admin console etc.
    /usr/bin/ssh -L"$myport":localhost:8080 -X -Y "$@"
}

# Reverse based listing of last 10 entries. Useful for listing my downloads directory.
# Defaults to time based listing. Pass in args (e.g. -S for size based).
# Defaults to current directory. Pass in optional directory.
# lt [-S] [<dir>]
function lt()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    ARGS="-t"
    while [[ "$1" == -* ]] ; do
       ARGS="$1" ; shift
    done

    local TARGET=$1

    [[ -z "$TARGET" ]] && TARGET="."
    [[ ! -d "$TARGET" ]] && echo "Usage: lt <directory>" && return

    # Was using https://lintut.com/colorize-log-files-on-linux-using-ccze-tool but
    # more comprehensive LS_COLORS is better.
    #
    # Final grep is to color the sizes :
    # https://unix.stackexchange.com/questions/77173/bash-colorize-second-column-of-output
    /bin/ls -F --color $ARGS -hlr $TARGET 2>&1 | tail -10 | grep --color -P "^(\S+\s+){4}\K\S+"


}

# Override for git to handle wrapping. I only want to use fmt for the log command.
function git()
{
   [[ -f /usr/local/bin/git ]] && local g=/usr/local/bin/git || local g=/usr/bin/git

   if [ "$1" = "clone" ]
   then
       $g "$@"
       [[ "$?" == "0" ]] && echo -e "\033[49;32;1mRemember to set local email *if* required via 'git config user.email xxxx'\033[0m"
   elif [ "$1" = "interactivestash" ]
   then
       echo -e "\033[49;32;1mUsage:\n\ny - stash this hunk\nn - do not stash this hunk\nq - quit; do not stash this hunk nor any of the remaining ones\na - stash this hunk and all later hunks in the file\nd - do not stash this hunk nor any of the later hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nJ - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nK - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\033[0m"
       $g "$@"
   elif [ "$GIT_NOCMDCONFIG" = "true" ]
   then
       GIT_PAGER="less -FrX" $g "$@"
   # Was using hardcoded width of 108 for columns - now dynamic.
   elif [ "$1" = "lg" ] || [ "$1" = "lg5" ]
   then
      $g -c core.pager="fmt -w `expr $COLUMNS + 25` -t | sed 's/^   /        /' | less -FrX" "$@"
   elif [ "$1" = "llg" ] || [ "$1" = "llg5" ]
   then
      $g -c core.pager="fmt -w `expr $COLUMNS + 22` -t | sed 's/^   /        /' | less -FrX"  "$@"
   else
      $g -c core.pager="less -FrJ" "$@"
   fi
}


# Recursive git implementation.
function rgit()
{
    (( $# == 0 )) && echo "Usage: $0 [-d <max-depth>] <git-cmd> ... [Run git command recursively over subdirs]" && return 1

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local i
    local cwd=$PWD
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"
    [[ "$1" = "-d" ]] && shift && local DEPTH=$1 && shift || local DEPTH="2"

    # Any ctrl-c breaks the loop and resets the directory.
    trap "cd $NOCHPWD $cwd && trap - 2 3 15 && break" 2 3 15

    for i in `find -L . -maxdepth $DEPTH -type d -name .git | env "LC_ALL=C" sort`
    do
        local d=`dirname $i | sed 's/\.\///'`
        cd $NOCHPWD $d

        echo -e "\033[49;32;1m### -> $d\033[0m"
        git "$@"
        [[ "$?" != "0" ]] && echo -e "\033[49;35;1mError running git command; ignoring...\033[0m"

        cd $NOCHPWD $cwd
    done

    trap - 2 3 15
}


# SVN Log implementation. It will print the log changes that are not in the local repository
# (or status message that we are up to date) and then print the last five local log entries.
# The problem occurs when we have mixed revisions in the working copy. It uses svnversion to
# try and establish the best point to do the log from.
function svnl()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local cwd=$PWD
    local log=5
    local textcol=32 # Green
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"

    while [[ $1 == -* ]]
    do
        [[ "$1" = "-e" ]]  && textcol="33" && shift # Hidden externals call
        [[ "$1" = "-v" ]]  && verbose="-v" && shift
        [[ "$1" = "-l" && -n "$2" ]] && log="$2" && shift && shift
    done

    # last-changed-revision is the last changed under the current path. If svnl
    # is not being run at top level then this can produce curious results.
    #
    # Using the below command will give the overall revision of HEAD.
    # Combining this with svnversion will give a comparison between current point and HEAD.

    # From http://austinmatzko.com/2008/04/26/sed-multi-line-search-and-replace/
    local lastremoterev=`svn info -r HEAD 2> /dev/null | sed -rn '
    # if the first line copy the pattern to the hold buffer
    1h
    # if not the first line then append the pattern to the hold buffer
    1!H
    # if the last line then ...
    $ {
        # copy from the hold to the pattern buffer
        g
        # do the search and replace
        s/.*Revision: ([0-9]*).*/\1/
        # print
        p
    }'`
    [[ -z "$lastremoterev" ]] && printf "$ERROR" "Not a svn repository" && return 1
    local revcheck=`svnversion .`

    if [ -n "`echo $revcheck | grep :`" ]
    then
        local subrange=`echo $revcheck | sed 's/.*:\([0-9]*\).*/\1/'`
        echo "Mixed revision working copy ($revcheck / range $subrange)"
    else
        local subrange=`echo $revcheck | sed 's/\([0-9]*\).*/\1/'`
    fi
    local EXTERNALS=`svn propget svn:externals -R | grep -E '^[a-zA-Z]+' | head -1 | awk '{print $1"/"$3}'`

    if [ $subrange != $lastremoterev ]
    then
        # Print remote log between HEAD and working copy 'base head' ignoring the last '-' line
        # We add one so to get the difference between HEAD and local + 1
        svn log $verbose -r HEAD:$(($subrange+1)) "$@" | head --lines=-1
    else
        echo "[Up to date (rev: $revcheck)]"
    fi
    echo -e "\033[49;$textcol;1m========================================================================\033[0m"
    # Print local log ignoring the first '-' line
    svn log $verbose -l $log "$@" | tail --lines=+2

    # svn log doesn't cross into externals directories so recursively check them as well.
    if [ -n "$EXTERNALS" ]
    then
         echo -e "\033[49;$textcol;1mExternals detected ($EXTERNALS):\033[0m"
         cd $NOCHPWD $EXTERNALS
         svnl -e -l 3
    fi

    cd $NOCHPWD $cwd
}


function _java_prompt_()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local oraclejava7=$SW_PREFIX/jdk1.7.0
    local oraclejava9=$SW_PREFIX/jdk-9
    local openjdk8=$SW_PREFIX/jdk8u392-b08
    local openjdk11=$SW_PREFIX/jdk-11
    local openjdk12=$SW_PREFIX/jdk-12.0.2+10
    local openjdk17=$SW_PREFIX/jdk-17
    local openjdk18=$SW_PREFIX/jdk-18.0.1+10/
    local openjdk21=$SW_PREFIX/jdk-21.0.3+9
    local i

    for i in $oraclejava7 $oraclejava9 $ibmjava6 $ibmjava7 $openjdk8 $$openjdk11 $openjdk12 $openjdk17 $openjdk18 $openjdk21
    do
        local replace="$i/bin:"
        PATH=`echo ${PATH//$replace/}`
    done

    case $1 in
      "oraclejava7")
        export JAVA_HOME=$oraclejava7
        ;;
      "oraclejava8")
        export JAVA_HOME=$oraclejava8
        ;;
      "oraclejava9")
        export JAVA_HOME=$oraclejava9
        ;;
      "openjdk8")
        export JAVA_HOME=$openjdk8
        ;;
      "openjdk11")
        export JAVA_HOME=$openjdk11
        ;;
      "openjdk12")
        export JAVA_HOME=$openjdk12
        ;;
      "openjdk17")
        export JAVA_HOME=$openjdk17
        ;;
      "openjdk18")
        export JAVA_HOME=$openjdk18
        ;;
      "openjdk21")
        export JAVA_HOME=$openjdk21
        ;;
    esac

    export PATH=$JAVA_HOME/bin:$PATH
}

function oraclejava7()
{
    _java_prompt_ oraclejava7

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(ORACLE7)%{"$'\e[00m''%}'
}

function oraclejava9()
{
    _java_prompt_ oraclejava9

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(ORACLE9)%{"$'\e[00m''%}'
}

function openjdk8()
{
    _java_prompt_ openjdk8

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(JAVA8)%{"$'\e[00m''%}'
}

function openjdk11()
{
    _java_prompt_ openjdk11

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(JAVA11)%{"$'\e[00m''%}'
}

function openjdk12()
{
    _java_prompt_ openjdk12

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(JAVA12)%{"$'\e[00m''%}'
}

function openjdk17()
{
    _java_prompt_ openjdk17

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(JAVA17)%{"$'\e[00m''%}'
}

function openjdk18()
{
    _java_prompt_ openjdk18

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(JAVA18)%{"$'\e[00m''%}'
}

function openjdk21()
{
    _java_prompt_ openjdk21

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(JAVA21)%{"$'\e[00m''%}'
}

function ant17()
{
    export ANT_HOME=$SW_PREFIX/apache-ant-1.7.0
    export PATH=$ANT_HOME/bin:$PATH

    alias ant='ant -logger org.apache.tools.ant.NoBannerLogger'
}

function ant18()
{
    export ANT_HOME=$SW_PREFIX/apache-ant-1.8.4
    export PATH=$ANT_HOME/bin:$PATH

    alias ant='ant -logger org.apache.tools.ant.NoBannerLogger'
}

function maven-3.0.3()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.0.3
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.0.4()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.0.4
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.0.5()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.0.5
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.1.1()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.1.1
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.2.3()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.2.3
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.2.5()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.2.5
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.3.3()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.3.3
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.3.9()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.3.9
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

# From Maven 3.5.0 and up M2_HOME is not strictly required.
function maven-3.5.0()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.5.0
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.6.0()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.6.0
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.6.1()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.6.1
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.6.2()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.6.2
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.6.3()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.6.3
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.8.1()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.8.1
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.8.5()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.8.5
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.8.7()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.8.7
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.9.0()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.9.0
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}
function maven-3.9.5()
{
    M2_HOME=$SW_PREFIX/apache-maven-3.9.5
    PATH=$M2_HOME/bin:`echo $PATH | awk -v RS=: -v ORS=: '/apache-maven/ {next} {print}'`
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

# https://github.com/gradle/gradle/issues/3117
function _gradle_daemon_workaround()
{
    PROMPT_SYMBOL="$"
    PROMPT_HAT=""
    function gitprompt_secondary()
    {
        :
    }
    echo "Unsetting PROMPT_HAT/SYMBOL to workaround Gradle daemon issues"
}

function gradle-2.13()
{
    PATH=$SW_PREFIX/gradle-2.13/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
    _gradle_daemon_workaround
}

function gradle-4.7()
{
    PATH=$SW_PREFIX/gradle-4.7/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
    _gradle_daemon_workaround
}

function gradle-4.8()
{
    PATH=$SW_PREFIX/gradle-4.8/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
    _gradle_daemon_workaround
}

function gradle-4.10.2()
{
    PATH=$SW_PREFIX/gradle-4.10.2/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
    _gradle_daemon_workaround
}

function gradle-5.1.1()
{
    PATH=$SW_PREFIX/gradle-5.1.1/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-5.3.1()
{
    PATH=$SW_PREFIX/gradle-5.3.1/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-5.4.1()
{
    PATH=$SW_PREFIX/gradle-5.4.1/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-5.5.1()
{
    PATH=$SW_PREFIX/gradle-5.5.1/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-5.6.2()
{
    PATH=$SW_PREFIX/gradle-5.6.2/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-5.6.4()
{
    PATH=$SW_PREFIX/gradle-5.6.4/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-6.0.1()
{
    PATH=$SW_PREFIX/gradle-6.0.1/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-6.3()
{
    PATH=$SW_PREFIX/gradle-6.3/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-6.5.1()
{
    PATH=$SW_PREFIX/gradle-6.5.1/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-6.7()
{
    PATH=$SW_PREFIX/gradle-6.7/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-6.8.3()
{
    PATH=$SW_PREFIX/gradle-6.8.3/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-7.1()
{
    PATH=$SW_PREFIX/gradle-7.1/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-7.2()
{
    PATH=$SW_PREFIX/gradle-7.2/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function gradle-7.3.3()
{
    PATH=$SW_PREFIX/gradle-7.3.3/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}
function gradle-7.4.1()
{
    PATH=$SW_PREFIX/gradle-7.4.1/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}
function gradle-7.5()
{
    PATH=$SW_PREFIX/gradle-7.5/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}
function gradle-7.6.1()
{
    PATH=$SW_PREFIX/gradle-7.6.1/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}
function gradle-8.1()
{
    PATH=$SW_PREFIX/gradle-8.1/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}
function gradle-8.2()
{
    PATH=$SW_PREFIX/gradle-8.2/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}
function gradle-8.3()
{
    PATH=$SW_PREFIX/gradle-8.3/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}
function gradle-8.5()
{
    PATH=$SW_PREFIX/gradle-8.5/bin:`echo $PATH | awk -v RS=: -v ORS=: '/gradle-/ {next} {print}'`
    echo "Gradle executable is `which gradle`"
}

function groovy-2.5.4()
{
    PATH=$SW_PREFIX/groovy-2.5.4/bin:$PATH
    echo "Groovy executable is `which groovy`"
}

function sbt-1.4.5()
{
    PATH=$SW_PREFIX/sbt/bin:$PATH
}

function unsignjar()
{
    [[ -z "$@" ]] && echo "Usage: unsignjar <jar> <jar>...." && return

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local i

    for i in "$@"
    do
        if [ ! -f $i ]
        then
            echo "Unable to find $i"
        else
            local RESULT="`zip -v $i -d 'META-INF/*.RSA' | grep deleting`"
            local RESULT="`zip -v $i -d 'META-INF/*.SF' | grep deleting`"
            [[ -n $RESULT ]] && echo "$i: $RESULT"
        fi
    done
}

function checkSigning()
{
    [[ -z "$@" ]] && echo "Usage: checkSigning <pattern> <jars>[default to all]" && return

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local i

    if [ -z "$2" ]
    then
        JARS="`find . -name "*.jar"`"
    else
        JARS="$2"
    fi

    for i in `echo $JARS`
    do
        if [ -n "`jar tf $i | grep '$1'`" ]
        then
            echo $i

            jarsigner -verbose -certs -verify $i | grep --after-context=8 --max-count=1 "$1.*\.class"
            jar tvf $i | grep RSA

            echo "===================================================="
            echo ""
        fi
    done
}

# Search jars and wars recursively for a pattern.
# Standard usage is [-v] <pattern>
function searchJars()
{
    # -i is hidden indent output flag for recursive calls
    [[ "$1" = "-i" ]] && shift && local INDENT=$1 && shift
    [[ "$1" = "-v" ]] && local VERBOSE=true && shift
    [[ -z "$1" ]] && echo "Usage: searchJars <pattern>" && return

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local i
    local pattern=`echo $1 | sed 's/\./\//g'`
    local cwd=$PWD
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"

    # Any ctrl-c breaks the loop and resets the directory.
    trap "cd $NOCHPWD $cwd && trap - 2 3 15 && break" 2 3 15

    for i in `find . \( -name "*.jar" -o -name "*.war" \)`
    do
        if $(zipinfo $i > /dev/null 2>&1) && [ -f $i ]
        then
            if [ -n "`jar tf $i | grep -E \"$pattern\"`" ]
            then
                echo "$INDENT""\033[49;32;1mFound pattern $pattern in $i\033[0m"
                if [ "$VERBOSE" = "true" ]
                then
                    echo "`jar vtf $i | grep -E $1 | sed 's/^/\t\t/g'`"
                fi
            elif [ "$VERBOSE" = "true" ]
            then
                echo "$INDENT""\033[49;35;1mDid not find pattern $pattern in $i\033[0m"
            fi
            if [ -n "`jar tf $i | grep -E '\.(war|jar)'`" ]
            then
                # Jar/war containing jar/war
                echo "$INDENT""Searching inside $i ..."
                local ddir=$PWD/`mktemp -d tmp.XXXXXX`
                unzip -q -d $ddir $i
                cd $NOCHPWD $ddir
                [[ "$VERBOSE" == "true" ]] && local v="-v"
                searchJars -i "$INDENT\t" $v $pattern
                cd $NOCHPWD ..
                rm -rf $ddir
            fi
        fi
    done

    trap - 2 3 15
}

# IP_TOOLING - checkout of make_mead location.
#
# Params:
#   -s [specify own maven settings file]
#   -a [DO NOT use the alt deployment repository of $HOME/tmp/deploy-local]
function mvn-mead-jenkins()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD
    local deploy="-DaltDeploymentRepository=koji-repo::default::file://$HOME/tmp/deploy-local"
    local options
    options=()

    while [ $1 ]
    do
        case "$1" in
          -s)
            shift
            local SETTINGS="$1"
            shift
            ;;
          -a)
            shift
            deploy=""
            ;;
          *)
            options+=("$1")
            shift
            ;;
        esac
    done
    [[ -z "$SETTINGS" ]] && local SETTINGS=$HOME/Work/maven-mead-ip6-jenkins.xml

    if [ -n "$IP_TOOLING" ]
    then
        local TRUST_STORE=-Djavax.net.ssl.trustStore=$IP_TOOLING/jssecacerts
        local TRUST_STORE_PASSWORD=-Djavax.net.ssl.trustStorePassword=changeit
        local TRUST_STORE_TYPE=-Djavax.net.ssl.trustStoreType=jks
        local KEY_STORE=-Djavax.net.ssl.keyStore=$IP_TOOLING/jssecacerts
        local KEY_STORE_PASSWORD=-Djavax.net.ssl.keyStorePassword=changeit
        local KEY_STORE_TYPE=-Djavax.net.ssl.keyStoreType=jks
        #    local DEBUG=-Djavax.net.debug=ssl:handshake:data

        local -x MAVEN_OPTS="$TRUST_STORE $KEY_STORE $TRUST_STORE_PASSWORD $KEY_STORE_PASSWORD $TRUST_STORE_TYPE $KEY_STORE_TYPE $DEBUG $MAVEN_OPTS"
    else
        echo "IP_TOOLING not set; not setting jssecacerts"
    fi

    mvn -s $SETTINGS $deploy "${options[@]}"
}


#
# Simplified wrapper for running make-mead makefiles.
#
# Note: .zshrc defines compdef completion for makemead to be make
#
# If this it run from a checkout then it will search CFG(default: builder.cfg) for
# the correct target to invoke.
#
# If this is run from the make-mead or integration-platform-config directory it will assume a *MEAD*
# build *and* only run a *SINGLE* build.
#
# Options as local variables:
# MVN_LOCAL_REPO: defaults to parsing from $HOME/Work/maven-mead-ip6.xml (unless SETTINGS is set). Override to local dir.
# REPO_GROUP: defaults to MEAD. See mead options for others e.g. MEAD+JENKINS+JBOSS+CENTRAL
# CHECK_MEAD: defaults to '0' i.e. off. Set to 1 to run MEAD_check_artifacts after.
#
function makemead()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"

    # Any ctrl-c resets the directory.
    trap "cd $NOCHPWD $BUILD_DIR && trap - 2 3 15" 2 3 15

    if [ -z "$IP_CONFIG" ]
    then
        printf "$ERROR" "Configure IP_CONFIG shell variable"
        return 1
    fi

    # Hack just to allow completion and grab the correct parameter
    local dryrun='cat'
    local options
    options=()
    while [ $1 ]
    do
        case "$1" in
          -f)
            shift
            shift
            ;;
          -n)
            dryrun='sed "s/--execute //"'
            options+=("$1")
            shift
            ;;
          -c)
            local clean=true
            shift
            ;;
          *)
            options+=("$1")
            shift
            ;;
        esac
    done

    [[ -z "$CFG" ]] && local -x CFG="$IP_CONFIG/builder.cfg"

    local gitreponame=`git remote -v | sed -nre 's/\s*origin\s*.*(\/)(.*)\s[(]fetch.*/\2/p'`

    if [ -z "$gitreponame" ]
    then
       printf "$ERROR" "Unable to determine git repository; aborting..."
       return
    fi

    echo "Git repository is \"$gitreponame\""

    if [ "$gitreponame" != "integration-platform-config.git" ]
    then
        local -x LOCAL=1
        local -x BUILD_DIR=$PWD
        local -x MVN_DEP_REPO="local::default::file://$HOME/tmp/deploy-local"
        # Place simulator workspace artifacts in a temporary directory.
        local -x WORKSPACE=/tmp/workspace/`mktemp -u XXXXXX`

        local target=`tac $CFG | awk -v gv=$gitreponame '$0 ~ /^scmURL/ && $0 ~ gv { a=$0 } /[[].*[]]/ && a { sub("\\\\[","") ; sub("\\\\]","") ; print $0; exit }'`
        [[ -z "$target" ]] && printf "$ERROR" "Unable to find a matching target" && return
        echo "Building $target in $BUILD_DIR"

        [[ -z "$SETTINGS" ]] && local SETTINGS=$HOME/Work/maven-mead-ip6.xml

        # If repo_group is not already set use mead.
        [[ -z "$REPO_GROUP" ]] && local -x REPO_GROUP=MEAD

        if [[ -z "$MVN_LOCAL_REPO" ]] && [[ -f $SETTINGS ]]
        then
            local -x MVN_LOCAL_REPO=$HOME/`cat $SETTINGS | sed -ne 's/.*\${user.home}\/\(.*\)<\/localRepository>/\1/p'`
            local TAG=`cat $SETTINGS | sed -ne 's/.*repos\/\(.*\)\/latest.*/\1/p'`
        elif [ -z "$MVN_LOCAL_REPO" ]
        then
            echo "\033[49;32;1mWARNING: Unable to find $SETTINGS to find a local repository; defaulting to $WORKSPACE/local-repository\033[0m"
        fi
        if [ "$clean" = "true" ]
        then
            echo "Cleaning..."
            git reset --hard
            rm -rf `find . -name target -type d`
            echo "Done cleaning..."
        fi

        # Hack : make files don't know how to include each other. Sigh.
        cd $NOCHPWD $IP_CONFIG
        # Hack : make files have no clean target right now.
        rm -f "$IP_CONFIG/$target".lastBuild
        rm -rf $WORKSPACE ; mkdir -p $WORKSPACE

        # Check for chain build
        if [ -n "`cat $CFG | grep buildrequires`" ]
        then
            target="-f `cat $CFG | grep makefile | sed 's/.*=//'` BUILDDEPS=\"\" ARTIFACT=$target"
            echo "Chain build support : $target"
        fi

        echo "Using\n\tWorkspace :\t\t$WORKSPACE\n\tREPO_GROUP :\t\t$REPO_GROUP\n\tMVN_LOCAL_REPO :\t$MVN_LOCAL_REPO\n\tMVN_DEP_REPO :\t\t$MVN_DEP_REPO\n\tPOMMANIPEXT :\t\t$POMMANIPEXT\n\tCFG :\t\t\t$CFG\n\tRESUME :\t\t$RESUME"
        make "${options[@]}" `echo $target` | eval $dryrun

        if [ "$CHECK_MEAD" = "1" ] && [[ -f $SETTINGS ]]
        then
            echo "Running MEAD_check_artifact.sh..."
            rm -f $BUILD_DIR/mead_check.log
            ./MEAD_check_artifact.sh $TAG $MVN_LOCAL_REPO > $BUILD_DIR/mead_check.log 2>&1
        fi

        cd $NOCHPWD $BUILD_DIR
    else
        local -x BREW=1
        make "${options[@]}" | eval $dryrun
    fi

    trap - 2 3 15
}


#
# This script is sourced from
# https://community.jboss.org/blogs/stuartdouglas/2011/09/06/merging-github-pull-requests?_sscc=t
# and is designed to handle pull requests from github without leading to merges
# in the history (it does a rebase instead.
function mergePullRequest()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    if [ "$1" = "-h" ] || [ "$1" = "--help" ]
    then
        echo "Usage: $0 [ -m (Prefer merge) ] [-r (remote e.g. upstream) ]  <pull id e.g. 14>"
        return
    fi
    if [ "$1" = "-m" ]
    then
        local preferMerge="true"
        shift
    fi
    if [ "$1" = "-r" ]
    then
        shift
        local cmd="git fetch $1 "
        shift
    else
        local cmd="git fetch origin "
    fi
    local branch=`git rev-parse --abbrev-ref HEAD`
    local tmpbranch=`uuidgen`

    for var in "$@"
    do
        cmd="$cmd pull/$var/head:pullRequest$var"
    done

    echo -e "\033[49;32;1m### -> Will merge pull request onto $branch\033[0m"

    echo "Running: '$cmd"
    eval $cmd

    for var in "$@"
    do
        git checkout pullRequest$var
        [[ "$?" != "0" ]] && printf "$ERROR" "Error checking out branch; aborting..." && return 1
        git lg -n 1
        local original=`git log -1 --pretty="%H"`

        if [ "$preferMerge" != "true" ]
        then
            git checkout -b $tmpbranch
            echo "### Rebasing to $branch"
            git rebase $branch
            [[ "$?" != "0" ]] && printf "$ERROR" "Error rebasing $branch; aborting..." && return 1
            git lg -n 1
            local new=`git log -1 --pretty="%H"`
        fi

        if [ "$original" != "$new" ]
        then
            echo "\033[49;32;1mGIT SHA do not match ; unable to rebase ; switching to merge\033[0m"
            git checkout $branch
            git merge --no-edit -m "Merge pull request #$var" --no-ff pullRequest$var
        else
            git checkout $branch
            [[ "$?" != "0" ]] && printf "$ERROR" "Error checking out branch; aborting..." && return 1
            echo "### Merging pullRequest$var"
            git merge $tmpbranch
            git lg -n 1
        fi
        [[ "$?" != "0" ]] && printf "$ERROR" "Error merging pull request; aborting..." && return 1
        git branch -D pullRequest$var
        [[ "$?" != "0" ]] && printf "$ERROR" "Error deleting branch; aborting..." && return 1
        if [ "$preferMerge" != "true" ]
        then
            git branch -D $tmpbranch
            [[ "$?" != "0" ]] && printf "$ERROR" "Error deleting branch; aborting..." && return 1
        fi
    done
    echo -e "\033[49;32;1mFinished\033[0m"
}


resetFeatureBranch ()
{
    local currentBranch=$(git symbolic-ref --short HEAD)
    local primary="$(git remote show origin | sed -n '/HEAD branch/s/.*: //p' | xargs)"
    local upstream=""
    if [ -z "$(git for-each-ref --format='%(refname:short)' refs/heads/ | grep $primary)" ]
    then
        # Assumption : current primary is a lower cased branch configured for push that doesn't match current branch.
        primary=$(git remote show origin | grep pushes | grep -E '^\s*[a-z]+.*' | sed -E 's/(\s*)([a-z].*)(.*pushes.*)/\2/' | xargs)
        # for branch in $(git for-each-ref --format='%(refname:short)' refs/heads)
        # do
        #     if [ "$branch" != "$currentBranch" ]
        #     then
        #        primary=$branch
        #        break
        #     fi
        # done
    fi
    for i in $(git trackbranch | grep -E '.* <- .+' | sed 's/\(.*\) <-.*/\1/g')
    do
        if [ "1" == $(git remote | wc -l) ]
        then
            local r="`git branch -a | grep remotes | grep -v HEAD | grep -E \"(upstream/$i|origin/$i)\" | head -1 | cut -f 3 -d ' '`"
        else
            local r="`git branch -a | grep remotes | grep -v HEAD | grep -E \"(upstream/$i)\" | head -1 | cut -f 3 -d ' '`"
        fi
        if [ -n "$r" ]
        then
            upstream="${r#remotes/}"
            break
        fi
    done
    [[ "$?" != "0" ]] && printf "$ERROR" "Error establishing current branch; aborting..." && return 1
    [[ -z "$currentBranch" ]] && printf "$ERROR" "Current branch not set" && return 1
    [[ -z "$primary" ]] && printf "$ERROR" "Primary branch not set" && return 1
    git llg5
    printf "$INFO" "Current branch is \"$currentBranch\""
    printf "$INFO" "Known 'primary' is \"$primary\""
    if [ -z "$upstream" ]
    then
        echo "No upstream configured ; assuming local PR and merge..."
    else
        printf "$INFO" "Upstream 'primary' \"$upstream\""
    fi
    echo ""
    [[ "$currentBranch" = "$primary" ]] && printf "$ERROR" "Current equals primary; aborting..." && return 1
    git checkout $primary
    [[ "$?" != 0 ]] && printf "$ERROR" "Unable to switch branch" && return 1
    echo "Deleting current and remote feature branch"
    git branch -D $currentBranch
    [[ -n "$(git ls-remote --exit-code --heads origin $currentBranch)" ]] && git push origin --delete $currentBranch
    if [ -n "$upstream" ]
    then
        echo "Updating local"
        git pull -q `echo $upstream | tr '/' ' '`
        git llg5
    fi
}


# Information sourced from
#  http://git-scm.com/book/ch8-2.html
#  http://dereenigne.org/git/git-svn-mirror
# Takes project source URL [target-dir]
gitsvnclone()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    [[ -z "$1" ]] && printf "$ERROR" "No source URL specified." && return 1
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"

    TARGETDIR=`basename $1`
    [[ -n "$2" ]] && TARGETDIR=$2

    [[ -d $TARGETDIR ]] && printf "$ERROR" "Target directory already exists" && return 1

    git svn --stdlayout --branches="branches/*/*" --tags="tags/*/*" clone $1 $TARGETDIR

    echo "Resetting tags and branches"
    cd  $NOCHPWD $TARGETDIR
    git for-each-ref refs/remotes/tags | cut -d / -f 4- | grep -v @ | while read tagname; do echo "Processing $tagname"; git tag "$tagname" "tags/$tagname"; git branch -r -d "tags/$tagname"; done
    echo "Done tags; now branches..."
    git for-each-ref refs/remotes | cut -d / -f 3- | grep -v @ | while read branchname; do echo "Processing $tagname"; git branch "$branchname" "refs/remotes/$branchname"; git branch -r -d "$branchname"; done
    echo "Completed cloning svn repository."
    echo ""
    echo "Now add a remote (git remote add gitapp ....)"
    echo "and push the tags: git push --tags gitapp"
}


#
# Quick hack to take a POM file and print all of its GAVs out.
#
function printBOMGAs
{
    which mvn >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Configure Maven" && return 1

    local WORKDIR=`mktemp -p /tmp -d XXXX --suffix=bomanalysis`
    # Default for my purposes for now...
    local POM="org.jboss.fuse.bom:jboss-fuse-parent:6.2.1.redhat-032"
    # Could be a file reference e.g. file://`pwd`/cli/target/pom-manipulation-ext-1.8.jar
    local PME="http://central.maven.org/maven2/org/commonjava/maven/ext/pom-manipulation-cli/1.8/pom-manipulation-cli-1.8.jar"

    while [ -n "$1" ]
    do
        case "$1" in
          --workdir)
            shift
            local WORKDIR=$1
            shift
            ;;
          --pom)
            shift
            local POM=$1
            shift
            ;;
          --pme)
            shift
            local PME=$1
            shift
            ;;
          --help)
            echo "Usage is $0 [--workdir <dir>] [--pom <e.g. org.jboss.fuse.bom:jboss-fuse-parent:6.2.1.redhat-032>] [--pme <PME location>]"
            return 1
            ;;
          *)
            break;
        esac
    done

    cd $WORKDIR
    echo "Using workdir `pwd`"

    # No need to clone the repo ; just use the deployed version
    # git clone --depth 1 --branch fuseenterprise-6.2.1.redhat-032 git@github.com:jboss-fuse/fuse.git
    [[ -f pom.xml ]] && echo "warning : pom.xml already exists in this directory. Clean up first." && return 1
    mvn -q org.apache.maven.plugins:maven-dependency-plugin:2.10:get \
        -DremoteRepositories=https://origin-repository.jboss.org/nexus/content/groups/ea,http://maven.repository.redhat.com/nexus/content/groups/product-earlyaccess \
        -Dartifact=$POM:pom \
        -Ddest=pom.xml
    [[ "$?" != 0 ]] && printf "$ERROR" "Error downloading" && return 1
    sed -i 's/<module.*//g' pom.xml
    sed -i 's/<\/module.*//g' pom.xml
    echo "Downloaded remote pom file; now running effective:pom"

    mvn -q help:effective-pom -Doutput=effective.pom
    [[ "$?" != 0 ]] && printf "$ERROR" "Error creating effective pom" && return 1

    /bin/mv -f pom.xml original-pom.xml
    /bin/mv -f effective.pom pom.xml

    echo "Renaming effective.pom -> pom.xml and running analysis..."
    curl -s -o`echo $PME | sed 's/.*\///g'` $PME
    /bin/rm -f allgavs.log allnonrhga.log
    java -jar `echo $PME | sed 's/.*\///g'` -p | grep -E -v '(Maven-Manipulation-Extension|Found the following dependencies)' > allgavs.log 2>&1


    echo "GAV count is `cat allgavs.log | wc -l`"
    echo "Non redhat GAV count is `cat allgavs.log | grep -v redhat | wc -l`"
    cat allgavs.log | grep -v redhat | awk '{print $1}' | sed -E 's/(.*):[a-z]+:[0-9]+.*/\1/g' | sort | uniq > allnonrhga.log
    echo "Non redhat GA count is `cat allnonrhga.log | wc -l`"

    # java -jar /home/rnc/Work/PME/pom-manipulation-ext/cli/target/pom-manipulation-cli-1.8-SNAPSHOT.jar -p | grep -E -v redhat | awk '{print $1}' | sed -E 's/(.*):[a-z]+:[0-9]+.*/\1/g' | sort | uniq > fabric8nonrhga.log
    # awk 'NR==FNR{a[$0];next} !($0 in a)' /tmp/fusenonrhga.log fabricnonrhga
    #cd ..
    #rm -rf $WORKDIR
}


# Same as list-tag-inheritance but trim off excess depth.
function blt()
{
    brew list-tag-inheritance $1 | sed -e 's/  │          .*/  │       [...tag continues...]/g' -e 's/              .*/              [...tag continues...]/g' | uniq | grep -E '...tag continues...|$'
}


# Token should be stored in $HOME/.travis/config.yml under a field of ' access_token: <id> '
# The Job ID is displayed in the build log after expanding "Build system information".
function restartTravisJob()
{
    [[ -z "$1" ]] && printf "$ERROR" "Specify job id" && return 1
    curl -s -X POST \
         -H "Content-Type: application/json" \
         -H "Accept: application/json" \
         -H "Travis-API-Version: 3" \
         -H "Authorization: token $(awk '{gsub(/ /, "", $1); if ($1 == "access_token") print $2; }' FS=':' $HOME/.travis/config.yml)" \
         -d '{ "quiet": true }' \
         https://api.travis-ci.org/job/$1/debug
}


# Find pull requests between tag and 'head'.
function findPRs()
{
    current_tag="$2"
    name_with_owner="$1"

    [[ -z "$name_with_owner" ]] && printf "$ERROR" "Pass 'organisation/repo' as first parameter" && return 1
    [[ -z "$current_tag" ]] && printf "$ERROR" "Pass tag as second parameter" && return 1
    [[ -z "$GITHUB_PRS_TOKEN" ]] && printf "$ERROR" "Define CHANGELOG_GITHUB_TOKEN environment variable" && return 1

    tags=$(curl -s -H "Authorization: Token $GITHUB_PRS_TOKEN" \
                "https://api.github.com/repos/$name_with_owner/tags")
    key=$(jq -r --arg current_tag $current_tag 'to_entries | .[] | select(.value.name == $current_tag) | .key' <<< "$tags")
    previous_tag=$(jq -r --arg index $((key+1)) '.[$index | tonumber].name' <<< "$tags")

    printf "$INFO" "Compare between $previous_tag & $current_tag"

    commits=$(curl -s -H "Authorization: Token $GITHUB_PRS_TOKEN" \
                   "https://api.github.com/repos/$name_with_owner/compare/$previous_tag...$current_tag" | \
                  jq -r '.commits[].sha')


    # Only have a query of maximum of 256 character so we only process 17 sha for each request
    count=0
    max_per_request=17
    while read sha; do
        if [ $count == 0 ]; then
            query="repo:$name_with_owner%20type:pr"
        fi
        query="$query%20SHA:%20${sha:0:7}"
        count=$((count+1))
        if ! (($count % $max_per_request)); then
            # echo "https://api.github.com/search/issues?q=$query"
            curl -s -H "Authorization: Token $GITHUB_PRS_TOKEN" \
                 "https://api.github.com/search/issues?q=$query" | jq -r '.items[] | [.html_url,.title] | @csv'
            #            "https://api.github.com/search/issues?q=$query" | jq -r '.items[].html_url'
            count=0
        fi
    done <<< "$commits"

}


#
# Use
#    exiftool -time:all -a -G0:1 -s <img>
# to print out all time related to <img>
#
function fixExifDate()
{
    which exiftool >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Install exiftool" && return 1
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"
    [[ "$1" == "-d" ]] && shift && local DRYRUN=true
    [[ ! -d $1 ]] && echo "Pass in valid root directory" && return 1

    local cwd=$PWD
    local IFS=$'\n'
    local index=0

    # Any ctrl-c breaks the loop and resets the directory.
    trap "cd $NOCHPWD $cwd && trap - 2 3 15" 2 3 15

    cd $NOCHPWD "$1"

#    set -x
    for i in $(find . -type f)
    do
        ((index+=1))
        printf "$INFO" "Examining: $i"
        local START=($(exiftool -time:all $i))

        # -time:all should be equivalent to:
        # -FileAccessDate -FileInodeChangeDate -ModifyDate -DateTimeOriginal -CreateDate
        # +1 / -1 second to modify date.
        # exiftool -ext JPG "-ModifyDate-=::1" -overwrite_original_in_place $i
        # exiftool -ext JPG "-ModifyDate+=::1" -overwrite_original_in_place $i
        if [ "$DRYRUN" != true ]
        then
            # Verify if there is a DateTimeOriginal tag to use.
            exiftool -a -G0:1 -s -execute -if '$DateTimeOriginal' -common_args -time:all $i > /dev/null 2>&1
            if [ "$?" != 0 ]
            then
                local localjpg=$(find $(dirname $i) -maxdepth 1 -iname *.jpg | head -1)
                echo "File $i does not have relevant time information; reverting to touch using information from \"$localjpg\""
                # Attempt to use a sibling JPG file (if it exists) so that we can still set modification date.
                if [ -z "$localjpg" ]
                then
                    printf "$ERROR" "Unable to find sibling jpg to extract date information from."
                else
                    touch -mt $(exiftool -s -s -s -d "%Y%m%d%H%M" -DateTimeOriginal $localjpg) $i
                fi
            else
                exiftool "-FileModifyDate<DateTimeOriginal" -overwrite_original_in_place $i
            fi
            local END=($(exiftool -s -s -s -time:all $i))
        else
            echo "Dry-run : for $i"
        fi
        echo -e "${START[1]}\t\t${END[1]}"
        echo -e "${START[2]}\t\t${END[2]}"
        echo -e "${START[3]}\t\t${END[3]}"
        echo -e "${START[4]}\t\t\t${END[4]}"
        echo -e "${START[5]}\t\t\t${END[5]}"
        echo -e "${START[6]}\t\t\t${END[6]}"

    done

    cd $NOCHPWD $cwd
    trap - 2 3 15
}

# https://stackoverflow.com/questions/37951114/direct-download-link-to-onedrive-file
# Minor fixes to base64/echo statements.
function onelink()
{
    echo "$1" | base64 -w 0 | sed "s/=$//;s/\//\_/g;s/\+/\-/g;s/^/https:\/\/api\.onedrive\.com\/v1\.0\/shares\/u\!/;s/$/\/root\/content/";
}


#
# Takes two arguments which may be either two directories or two files. In the former case it will examine all files
# within those respective directories.
function compareImageFiles()
{
    which identify >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Install identify" && return 1
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"
    [[ "$1" == "-d" ]] && shift && local DRYRUN=true
    [[ -z "$1" || -z "$2" ]] && echo "Must pass in two parameters" && return 1

    local cwd=$PWD
    local IFS=$'\n'

    # Any ctrl-c breaks the loop and resets the directory.
    trap "cd $NOCHPWD $cwd && trap - 2 3 15" 2 3 15

    cd $NOCHPWD "$1"
    local basepath=$PWD

    #set -x
    for i in $(find $basepath -type f)
    do
        local targetFile=${i#$basepath}

        printf "$INFO" "Examining: $i"

        if [ ! -f $2/$targetFile ]
        then
            printf "$ERROR" "No file for $2/$targetFile"
        else
            diff <(md5sum $i | awk '{print $1}') <(md5sum $2/$targetFile | awk '{print $1}') > /dev/null
            if [ $? != 0 ]
            then
                diff <(identify -format "%#\n" $i) <(identify -format "%#\n" $2/$targetFile)
                if [ $? != 0 ]
                then
                    printf "$ERROR" "Image and metadata do not match for $targetFile"
                else
                    echo "Image matches but not metadata for $targetFile"
                fi
            fi
        fi
    done

    cd $NOCHPWD $cwd
    trap - 2 3 15
}


searchForMissingModel()
{
    which identify >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Install identify" && return 1
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"
    [[ "$1" == "-d" ]] && shift && local DRYRUN=true
#    [[ -z "$1" || -z "$2" ]] && echo "Must pass in two parameters" && return 1

    local cwd=$PWD
    local IFS=$'\n'

    # Any ctrl-c breaks the loop and resets the directory.
    trap "echo Exited!; return" 2 3 15
    #trap "cd $NOCHPWD $cwd && trap - 2 3 15" 2 3 15

    # set -x
    for i in $(find $1 -iname "IMG-*.jpg")
    do
        local result=""
        local partialresult=""
        local filename=$(basename "$i")
        local extension="${filename##*.}"

        if [ ! -n "$(exiftool -Model $i)" ]
        then
            echo "No model found for $i"
            mv $i WhatsApp
        fi
    done

    #trap - 2 3 15
}


searchForMatchingFiles()
{
    which identify >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Install identify" && return 1
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"
    [[ "$1" == "-d" ]] && shift && local DRYRUN=true
    [[ -z "$1" || -z "$2" ]] && echo "Must pass in two parameters" && return 1

    local cwd=$PWD
    local IFS=$'\n'

    # Any ctrl-c breaks the loop and resets the directory.
    trap "cd $NOCHPWD $cwd ; return" 2 3 15

    #set -x
    for i in $(find $1 -iname "*.jpg")
    do
        local result=""
        local partialresult=""
        local filename=$(basename "$i")
        local extension="${filename##*.}"
        echo "Looking at $i and $j"

        for j in $(find $2 -iname "*.$extension")
        do
            diff <(md5sum $i | awk '{print $1}') <(md5sum $j | awk '{print $1}') > /dev/null
            if [ $? == 0 ]
            then
                result=$j
                break
            fi
            diff <(identify -format "%#\n" $i 2> /dev/null) <(identify -format "%#\n" $j 2> /dev/null) > /dev/null
            if [ $? == 0 ]
            then
                result=$j
                break
            fi
            exiftool -filename -if "\$createdate eq \"$(exiftool -s -s -s -CreateDate $i)\"" -ext jpg $j > /dev/null
            if [ $? == 0 ]
            then
                partialresult=$j
                break
            fi
        done
        if [ -n "$partialresult" ]
        then
            echo "Found partial $partialresult for $i"
        elif [ -n "$result" ]
        then
            echo "Found $result for $i"
        else
            echo "Did not find matching file for $i"
        fi
    done

    trap - 2 3 15
}

searchForMatchingUsingExifDate()
{
    which identify >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Install identify" && return 1
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"
    [[ "$1" == "-d" ]] && shift && local DRYRUN=true
    [[ -z "$1" || -z "$2" ]] && echo "Must pass in two parameters" && return 1

    local cwd=$PWD
    local IFS=$'\n'

    # Any ctrl-c breaks the loop and resets the directory.
    trap "cd $NOCHPWD $cwd && trap - 2 3 15 && return" 2 3 15

    #set -x
    for i in $(find $1 -type f) # -iname "*.jpg")
    do
        local result=""
        local partialresult=""
        local filename=$(basename "$i")
        local extension="${filename##*.}"

        printf "$INFO" "Examining: $i (extension $extension)"

        local j="Pictures/Camera Roll/$(exiftool -s -s -s -d "%Y%m%d_%H%M%S" -CreateDate $i).$extension"
        if [ ! -f "$j" ]
        then
            j=`/bin/ls -1 "Pictures/Camera Roll/$(exiftool -s -s -s -d "%Y%m%d_%H%M%S" -CreateDate $i)"* | tail -1` 2> /dev/null
        fi

        if [ ! -f "$j" ]
        then
            echo "Did not find matching file for $i"
        else
            diff <(md5sum $i | awk '{print $1}') <(md5sum $j | awk '{print $1}') > /dev/null
            if [ $? == 0 ]
            then
                result=$j
            else
                diff <(identify -format "%#\n" $i 2> /dev/null) <(identify -format "%#\n" $j 2> /dev/null) > /dev/null
                if [ $? == 0 ]
                then
                    result=$j
                else
                    exiftool -filename -if "\$createdate eq \"$(exiftool -s -s -s -CreateDate $i)\"" -ext jpg $j > /dev/null
                    if [ $? == 0 ]
                    then
                        partialresult=$j
                    fi
                fi
            fi
            if [ -n "$partialresult" ]
            then
                echo "Found partial $partialresult for $i"
            elif [ -n "$result" ]
            then
                echo "Found $result for $i"
            else
                echo "Did not find matching file for $i"
            fi
        fi
    done
}

#
# https://docs.docker.com/engine/install/fedora/
# https://dev.to/yzwdroid/fedora-33-docker-445k
# https://nts.strzibny.name/how-to-set-up-shared-folders-in-virt-manager/
# https://jfearn.fedorapeople.org/fdocs/en-US/Fedora/20/html/Security_Guide/sec-Security-Enhanced_Linux-sVirt_Labeling.html
# https://www.cyberciti.biz/faq/linux-determine-virtualization-technology-command/
function cekitVMMount()
{
    sudo mkdir -p /opt/cekit
    sudo mount -t 9p -o trans=virtio,version=9p2000.L,rw /mnt/cekit /opt/cekit
}
function cekitUpdate()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local cwd=$PWD

    # If we are on the host copy TO the selinux enabled mount point
    if [ "`systemd-detect-virt`" = "none" ]
    then
        cd /home/rnc/Work/CEKit/GitHub/cekit
        find . -name "*.yaml" | cpio -pdmu /opt/cekit
        find . -name "*.yml" | cpio -pdmu /opt/cekit
        find . -name "*.py" | cpio -pdmu /opt/cekit
        find . -name "*.txt" | cpio -pdmu /opt/cekit
        find . -name "*.jinja" | cpio -pdmu /opt/cekit
        cd $cwd
    # Otherwise on the guest copy FROM the mounted point
    else
        cd /opt/cekit
        find . -name "*.yaml" | cpio -pdmu /home/rnc/Work/cekit
        find . -name "*.yml" | cpio -pdmu /home/rnc/Work/cekit
        find . -name "*.py" | cpio -pdmu /home/rnc/Work/cekit
        find . -name "*.txt" | cpio -pdmu /home/rnc/Work/cekit
        find . -name "*.jinja" | cpio -pdmu /home/rnc/Work/cekit
        cd $cwd
    fi
}


function collateDocuments()
{
    [[ -z "$1" ]] && echo "Pass in name of file to collate to" && return 1
    [[ -z "$ZSH_VERSION" ]] && echo "ZSH Only" && return 1
    which pdfunite >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Install pdfunite" && return 1


    local name=${(L)1}
    local folder=${(C)name}

    echo "Generating $name.pdf and moving Scan files to $folder"
    pdfunite S* "$name".pdf
    mkdir $folder
    mv S* $folder
}



function rhtapStaging()
{
    export KUBECONFIG=$HOME/Work/JBS/kube-config
}


# Doesn't appear to work quite right - ripgrep seems a better option.
#function allgrep()
#{
#    grep -Ini "$@" (^(target|vendor|.quinoa|.cache|node_modules)/)##*(.)
#}

function rg()
{
    # Could add these to $HOME/.ripgreprc but this consolidates into my version control while keeping a record.
    #
    # Search hidden files (but not .git) by default: https://github.com/BurntSushi/ripgrep/issues/623
    # Sort output by path. Slightly slower as disable parallelism
    /usr/bin/rg --hidden --sort path --glob '!.git' "$@"
}
