# -*- sh -*-
#

#################
### Variables ###
#################

UARCH=`uname -sm`
ARCH=`uname -m`
HOST=`hostname | sed 's/\..*//'`
ARCHBIN="$HOME/bin/`echo $UARCH| sed 's/ /\//'`"
PATH=$PATH:$HOME/bin

[[ -z $EDITOR ]] && EDITOR="emacs -nw --no-init-file --no-site-file"

SVN_EDITOR="$EDITOR"

export UARCH ARCH HOST ARCHBIN EDITOR SVN_EDITOR

if tput setaf 0 &>/dev/null
then
    # https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux
    OFF="$(tput sgr0)"
    BOLD="$(tput bold)"
    RED="$(tput setaf 1)"
    GREEN="$(tput setaf 2)"
    YELLOW="$(tput setaf 3)"
    BLUE="$(tput setaf 4)"
    WHITE="$(tput setaf 7)"
    ERROR="${BOLD}${RED}%s${OFF}\n"
fi

#################
### Functions ###
#################

# Note - unset NO_LOCAL_OPTIONS from .zshrc as using LOCAL_OPTIONS in
# below functions to override .zshrc options temporarily. Also tried
# resetting zsh to known default using emulate -L zsh but my nested
# function calls don't work correctly then.

if [ "$SHELL" = "/bin/bash" ] || [ "$SHELL" = "/usr/bin/bash" ]
then
    # If we are a bash shell define noop function to work around zsh specific calls.
    function setopt ()
    {
        :
    }
fi
git -c core.pager="less" >& /dev/null
[[ "$?" == "129" ]] && GIT_NOCMDCONFIG=true


# If we are printing the environment (no arguments) print it sorted.
function env()
{
    if [ $# == 0 ]
    then
        /usr/bin/env | env "LC_ALL=C" sort
    else
        /usr/bin/env "$@"
    fi
}


# Coloured manpages. An alternative using lynx is 'man -Hlynx less'
function man() {
    env \
        LESS_TERMCAP_mb=$'\E[01;31m' \
        LESS_TERMCAP_md=$'\E[01;38;5;74m' \
        LESS_TERMCAP_me=$'\E[0m' \
        LESS_TERMCAP_se=$'\E[0m' \
        LESS_TERMCAP_so=$'\E[38;5;246m' \
        LESS_TERMCAP_ue=$'\E[0m' \
        LESS_TERMCAP_us=$'\E[04;38;5;146m' \
        GROFF_NO_SGR=yes \
        man "$@"
}

# Note: while this does create a tunnel by default, it uses a different local port (18080)
# to avoid clashing with any local processes.
#
# It is recommended to store in your $HOME/.ssh/config your entries as per e.g.
#
#    Host <alias-name>
#       HostName <real-host-name>
#       User <user-name>
#       IdentityFile <RSA pub file>
#
function ssh()
{
    # Attempt to find a free local port to use.
    local myport
    local -a ports
    ports=(18080 18081 18082 18083 18084 18085 18086 18087 18088 18089 18090 18091 18092 18093 18094 18095 18096 18097 18098 18099 18100)
    for myport in ${ports[@]}; do
        lsof -i -n -P | grep LISTEN | grep -q ":${myport}"
        [ "$?" -eq 1 ] && break
    done
    echo "Using forwarding port $myport"

    # Default to also creating a SSH tunnnel as well. Useful if we are doing smoke testing
    # and we need to see the admin console etc.
    /usr/bin/ssh -L"$myport":localhost:8080 -X -Y "$@"
}

# Reverse based listing of last 10 entries. Useful for listing my downloads directory.
# Defaults to time based listing. Pass in args (e.g. -S for size based).
# Defaults to current directory. Pass in optional directory.
# lt [-S] [<dir>]
function lt()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    ARGS="-t"
    while [[ "$1" == -* ]] ; do
       ARGS="$1" ; shift
    done

    local TARGET=$1

    [[ -z "$TARGET" ]] && TARGET="."
    [[ ! -d "$TARGET" ]] && echo "Usage: lt <directory>" && return

    ls $ARGS -lr $TARGET 2>&1 | tail -10
}

function eclipse()
{
    (
        oraclejava7

        if [ "-h" == "$1" ]
        then
            echo "Usage: [eclipse-binary-to-start] (else default eclipse is started)"
            return 1
        fi

        # Override GTK settings for running in KDE - fixes a tooltip issue.
        [[ "$KDE_FULL_SESSION" = "true" ]] && local -x GTK2_RC_FILES=$HOME/.gtkrc-2.0-eclipse:$GTK2_RC_FILES

        rm -f /tmp/eclipse.log

        /usr/bin/eclipse &> /tmp/eclipse.log
    )
}

# Override for git to handle wrapping. I only want to use fmt for the log command.
function git()
{
   [[ -f /usr/local/bin/git ]] && local g=/usr/local/bin/git || local g=/usr/bin/git

   if [ "$1" = "clone" ]
   then
       $g "$@"
       [[ "$?" == "0" ]] && echo -e "\033[49;32;1mRemember to set local email *if* required via 'git config user.email xxxx'\033[0m"
   elif [ "$1" = "interactivestash" ]
   then
       echo -e "\033[49;32;1mUsage:\n\ny - stash this hunk\nn - do not stash this hunk\nq - quit; do not stash this hunk nor any of the remaining ones\na - stash this hunk and all later hunks in the file\nd - do not stash this hunk nor any of the later hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nJ - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nK - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\033[0m"
       $g "$@"
   elif [ "$GIT_NOCMDCONFIG" = "true" ]
   then
       GIT_PAGER="less -FrX" $g "$@"
   # Was using hardcoded width of 108 for columns - now dynamic.
   elif [ "$1" = "lg" ] || [ "$1" = "lg5" ]
   then
      $g -c core.pager="fmt -w `expr $COLUMNS + 25` -t | sed 's/^   /        /' | less -FrX" "$@"
   elif [ "$1" = "llg" ] || [ "$1" = "llg5" ]
   then
      $g -c core.pager="fmt -w `expr $COLUMNS + 22` -t | sed 's/^   /        /' | less -FrX"  "$@"
   else
      $g -c core.pager="less -FrJ" "$@"
   fi
}


# Recursive git implementation.
function rgit()
{
    (( $# == 0 )) && echo "Usage: $0 [-d <max-depth>] <git-cmd> ... [Run git command recursively over subdirs]" && return 1

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local i
    local cwd=$PWD
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"
    [[ "$1" = "-d" ]] && shift && local DEPTH=$1 && shift || local DEPTH="2"

    # Any ctrl-c breaks the loop and resets the directory.
    trap "cd $NOCHPWD $cwd && trap - 2 3 15 && break" 2 3 15

    for i in `find -L . -maxdepth $DEPTH -type d -name .git | env "LC_ALL=C" sort`
    do
        local d=`dirname $i | sed 's/\.\///'`
        cd $NOCHPWD $d

        echo -e "\033[49;32;1m### -> $d\033[0m"
        git "$@"
        [[ "$?" != "0" ]] && echo -e "\033[49;35;1mError running git command; ignoring...\033[0m"

        cd $NOCHPWD $cwd
    done

    trap - 2 3 15
}


# SVN Log implementation. It will print the log changes that are not in the local repository
# (or status message that we are up to date) and then print the last five local log entries.
# The problem occurs when we have mixed revisions in the working copy. It uses svnversion to
# try and establish the best point to do the log from.
function svnl()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local cwd=$PWD
    local log=5
    local textcol=32 # Green
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"

    while [[ $1 == -* ]]
    do
        [[ "$1" = "-e" ]]  && textcol="33" && shift # Hidden externals call
        [[ "$1" = "-v" ]]  && verbose="-v" && shift
        [[ "$1" = "-l" && -n "$2" ]] && log="$2" && shift && shift
    done

    # last-changed-revision is the last changed under the current path. If svnl
    # is not being run at top level then this can produce curious results.
    #
    # Using the below command will give the overall revision of HEAD.
    # Combining this with svnversion will give a comparison between current point and HEAD.

    # From http://austinmatzko.com/2008/04/26/sed-multi-line-search-and-replace/
    local lastremoterev=`svn info -r HEAD 2> /dev/null | sed -rn '
    # if the first line copy the pattern to the hold buffer
    1h
    # if not the first line then append the pattern to the hold buffer
    1!H
    # if the last line then ...
    $ {
        # copy from the hold to the pattern buffer
        g
        # do the search and replace
        s/.*Revision: ([0-9]*).*/\1/
        # print
        p
    }'`
    [[ -z "$lastremoterev" ]] && printf "$ERROR" "Not a svn repository" && return 1
    local revcheck=`svnversion .`

    if [ -n "`echo $revcheck | grep :`" ]
    then
        local subrange=`echo $revcheck | sed 's/.*:\([0-9]*\).*/\1/'`
        echo "Mixed revision working copy ($revcheck / range $subrange)"
    else
        local subrange=`echo $revcheck | sed 's/\([0-9]*\).*/\1/'`
    fi
    local EXTERNALS=`svn propget svn:externals -R | egrep '^[a-zA-Z]+' | head -1 | awk '{print $1"/"$3}'`

    if [ $subrange != $lastremoterev ]
    then
        # Print remote log between HEAD and working copy 'base head' ignoring the last '-' line
        # We add one so to get the difference between HEAD and local + 1
        svn log $verbose -r HEAD:$(($subrange+1)) "$@" | head --lines=-1
    else
        echo "[Up to date (rev: $revcheck)]"
    fi
    echo -e "\033[49;$textcol;1m========================================================================\033[0m"
    # Print local log ignoring the first '-' line
    svn log $verbose -l $log "$@" | tail --lines=+2

    # svn log doesn't cross into externals directories so recursively check them as well.
    if [ -n "$EXTERNALS" ]
    then
         echo -e "\033[49;$textcol;1mExternals detected ($EXTERNALS):\033[0m"
         cd $NOCHPWD $EXTERNALS
         svnl -e -l 3
    fi

    cd $NOCHPWD $cwd
}


function _java_prompt_()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    [[ -z "$1" && "$1" != "oraclejava5" && "$1" != "oraclejava6" && "$1" != "oraclejava7" \
        && "$1" != "ibmjava6"  && "$1" != "ibmjava7" ]] && printf "$ERROR" "Private java setup function" && return

    local oraclejava5=/usr/local/jdk1.5.0
    local oraclejava6=/usr/local/jdk1.6.0
    local oraclejava7=/usr/local/jdk1.7.0
    local oraclejava8=/usr/local/jdk1.8.0
    local ibmjava6=/usr/local/ibm-jdk1.6.0
    local ibmjava7=/usr/local/ibm-jdk1.7.0
    local i

    for i in $oraclejava5 $oraclejava6 $oraclejava7 $oraclejava8 $ibmjava6 $ibmjava7
    do
        local replace="$i/bin:"
        PATH=`echo ${PATH//$replace/}`
    done

    case $1 in
      "oraclejava5")
        export JAVA_HOME=$oraclejava5
        ;;
      "oraclejava6")
        export JAVA_HOME=$oraclejava6
        ;;
      "oraclejava7")
        export JAVA_HOME=$oraclejava7
        ;;
      "oraclejava8")
        export JAVA_HOME=$oraclejava8
        ;;
      "ibmjava6")
        export JAVA_HOME=$ibmjava6
        ;;
      "ibmjava7")
        export JAVA_HOME=$ibmjava7
        ;;
    esac

    export PATH=$JAVA_HOME/bin:$PATH
}

function oraclejava5()
{
    _java_prompt_ oraclejava5

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(ORACLE5)%{"$'\e[00m''%}'
}

function oraclejava6()
{
    _java_prompt_ oraclejava6

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(ORACLE6)%{"$'\e[00m''%}'
}

function oraclejava7()
{
    _java_prompt_ oraclejava7

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(ORACLE7)%{"$'\e[00m''%}'
}

function oraclejava8()
{
    _java_prompt_ oraclejava8

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(ORACLE8)%{"$'\e[00m''%}'
}

function ibmjava6()
{
    _java_prompt_ ibmjava6

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(IBM6)%{"$'\e[00m''%}'
}

function ibmjava7()
{
    _java_prompt_ ibmjava7

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(IBM7)%{"$'\e[00m''%}'
}

function ant17()
{
    export ANT_HOME=/usr/local/apache-ant-1.7.0
    export PATH=$ANT_HOME/bin:$PATH

    alias ant='ant -logger org.apache.tools.ant.NoBannerLogger'
}

function ant18()
{
    export ANT_HOME=/usr/local/apache-ant-1.8.4
    export PATH=$ANT_HOME/bin:$PATH

    alias ant='ant -logger org.apache.tools.ant.NoBannerLogger'
}

function maven-3.0.3()
{
    M2_HOME=/usr/local/apache-maven-3.0.3
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.0.4()
{
    M2_HOME=/usr/local/apache-maven-3.0.4
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.0.5()
{
    M2_HOME=/usr/local/apache-maven-3.0.5
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.0.5-prod()
{
    M2_HOME=/usr/local/apache-maven-3.0.5-prod
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.1.1()
{
    M2_HOME=/usr/local/apache-maven-3.1.1
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.1.1-prod()
{
    M2_HOME=/usr/local/apache-maven-3.1.1-prod
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.2.3-prod()
{
    M2_HOME=/usr/local/apache-maven-3.2.3-prod
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.2.5()
{
    M2_HOME=/usr/local/apache-maven-3.2.5
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.2.5-prod()
{
    M2_HOME=/usr/local/apache-maven-3.2.5-prod
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.3.3()
{
    M2_HOME=/usr/local/apache-maven-3.3.3
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.3.3-prod()
{
    M2_HOME=/usr/local/apache-maven-3.3.3-prod
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function maven-3.3.9()
{
    M2_HOME=/usr/local/apache-maven-3.3.9
    PATH=$M2_HOME/bin:$PATH
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function gradle-2.13()
{
    PATH=/usr/local/gradle-2.13/bin:$PATH
    echo "Gradle executable is `which gradle`"
}

#
# Call <url>
#
function _update-maven-extensions()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD


    if [ -z "$1" ]
    then
        printf "$ERROR" "Invalid URL for new version"
        return 1
    else
        local f1=/tmp/`echo $1 | sed 's/.*\///g'`
        curl -o$f1 $1
        if [ "$?" != 0 ]
        then
            printf "$ERROR" "Unable to find $1"
            return 1
        fi
    fi

    if [ "$SHELL" = "/bin/bash" ] || [ "$SHELL" = "/usr/bin/bash" ]
    then
        local PRODMVN="`functions -F | grep -- -prod | sed 's/declare -f //g' |  tr '\n' ' '`"
    else
        # ZSH
        local PRODMVN="`print -l ${(ok)functions}|grep -- -prod | tr '\n' ' '`"
    fi

    # Use a temporary file as we can't use sudo with a function
    content="#!/bin/bash\n
    file=\$1 ; shift
    for m in `echo \\$*`
    do
        echo \"\033[49;32;1mProcessing \$m\033[0m\"
        /bin/rm -fv /usr/local/apache-\$m/lib/ext/*.jar
        /bin/cp -v \$file /usr/local/apache-\$m/lib/ext
    done
    "
    local f2=`mktemp`
    echo "Writing content to $f2"
    echo -e "$content" >> "$f2"
    chmod uog+x $f2

    echo "Executing... sudo $f2 $f1 $PRODMVN"

    sudo $f2 $f1 $PRODMVN

    /bin/rm -f $f1 $f2

}

function unsignjar()
{
    [[ -z "$@" ]] && echo "Usage: unsignjar <jar> <jar>...." && return

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local i

    for i in "$@"
    do
        if [ ! -f $i ]
        then
            echo "Unable to find $i"
        else
            local RESULT="`zip -v $i -d 'META-INF/*.RSA' | grep deleting`"
            local RESULT="`zip -v $i -d 'META-INF/*.SF' | grep deleting`"
            [[ -n $RESULT ]] && echo "$i: $RESULT"
        fi
    done
}

function checkSigning()
{
    [[ -z "$@" ]] && echo "Usage: checkSigning <pattern> <jars>[default to all]" && return

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local i

    if [ -z "$2" ]
    then
        JARS="`find . -name "*.jar"`"
    else
        JARS="$2"
    fi

    for i in `echo $JARS`
    do
        if [ -n "`jar tf $i | grep $1`" ]
        then
            echo $i

            jarsigner -verbose -certs -verify $i | grep --after-context=8 --max-count=1 "$1.*\.class"
            jar tvf $i | grep RSA

            echo "===================================================="
            echo ""
        fi
    done
}

# Search jars and wars recursively for a pattern.
# Standard usage is [-v] <pattern>
function searchJars()
{
    # -i is hidden indent output flag for recursive calls
    [[ "$1" = "-i" ]] && shift && local INDENT=$1 && shift
    [[ "$1" = "-v" ]] && local VERBOSE=true && shift
    [[ -z "$1" ]] && echo "Usage: searchJars <pattern>" && return

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local i
    local pattern=`echo $1 | sed 's/\./\//g'`
    local cwd=$PWD
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"

    # Any ctrl-c breaks the loop and resets the directory.
    trap "cd $NOCHPWD $cwd && trap - 2 3 15 && break" 2 3 15

    for i in `find . \( -name "*.jar" -o -name "*.war" \)`
    do
        if [ -f $i ]
        then
            if [ -n "`jar tf $i | egrep \"$pattern\"`" ]
            then
                echo "$INDENT""\033[49;32;1mFound pattern $pattern in $i\033[0m"
                if [ "$VERBOSE" = "true" ]
                then
                    echo "`jar vtf $i | egrep $1 | sed 's/^/\t\t/g'`"
                fi
            elif [ "$VERBOSE" = "true" ]
            then
                echo "$INDENT""\033[49;35;1mDid not find pattern $pattern in $i\033[0m"
            fi
            if [ -n "`jar tf $i | egrep '(war|jar)'`" ]
            then
                # Jar/war containing jar/war
                echo "$INDENT""Searching inside $i ..."
                local ddir=$PWD/`mktemp -d tmp.XXXXXX`
                unzip -q -d $ddir $i
                cd $NOCHPWD $ddir
                [[ "$VERBOSE" == "true" ]] && local v="-v"
                searchJars -i "$INDENT\t" $v $pattern
                cd $NOCHPWD ..
                rm -rf $ddir
            fi
        fi
    done

    trap - 2 3 15
}

# IP_TOOLING - checkout of make_mead location.
#
# Params:
#   -s [specify own maven settings file]
#   -a [DO NOT use the alt deployment repository of $HOME/tmp/deploy-local]
function mvn-mead-jenkins()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD
    local deploy="-DaltDeploymentRepository=koji-repo::default::file://$HOME/tmp/deploy-local"
    local options
    options=()

    while [ $1 ]
    do
        case "$1" in
          -s)
            shift
            local SETTINGS="$1"
            shift
            ;;
          -a)
            shift
            deploy=""
            ;;
          *)
            options+=("$1")
            shift
            ;;
        esac
    done
    [[ -z "$SETTINGS" ]] && local SETTINGS=$HOME/Work/maven-mead-ip6-jenkins.xml

    if [ -n "$IP_TOOLING" ]
    then
        local TRUST_STORE=-Djavax.net.ssl.trustStore=$IP_TOOLING/jssecacerts
        local TRUST_STORE_PASSWORD=-Djavax.net.ssl.trustStorePassword=changeit
        local TRUST_STORE_TYPE=-Djavax.net.ssl.trustStoreType=jks
        local KEY_STORE=-Djavax.net.ssl.keyStore=$IP_TOOLING/jssecacerts
        local KEY_STORE_PASSWORD=-Djavax.net.ssl.keyStorePassword=changeit
        local KEY_STORE_TYPE=-Djavax.net.ssl.keyStoreType=jks
        #    local DEBUG=-Djavax.net.debug=ssl:handshake:data

        local -x MAVEN_OPTS="$TRUST_STORE $KEY_STORE $TRUST_STORE_PASSWORD $KEY_STORE_PASSWORD $TRUST_STORE_TYPE $KEY_STORE_TYPE $DEBUG $MAVEN_OPTS"
    else
        echo "IP_TOOLING not set; not setting jssecacerts"
    fi

    mvn -s $SETTINGS $deploy "${options[@]}"
}


#
# Simplified wrapper for running make-mead makefiles.
#
# Note: .zshrc defines compdef completion for makemead to be make
#
# If this it run from a checkout then it will search CFG(default: builder.cfg) for
# the correct target to invoke.
#
# If this is run from the make-mead or integration-platform-config directory it will assume a *MEAD*
# build *and* only run a *SINGLE* build.
#
# Options as local variables:
# MVN_LOCAL_REPO: defaults to parsing from $HOME/Work/maven-mead-ip6.xml (unless SETTINGS is set). Override to local dir.
# REPO_GROUP: defaults to MEAD. See mead options for others e.g. MEAD+JENKINS+JBOSS+CENTRAL
# CHECK_MEAD: defaults to '0' i.e. off. Set to 1 to run MEAD_check_artifacts after.
#
function makemead()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"

    # Any ctrl-c resets the directory.
    trap "cd $NOCHPWD $BUILD_DIR && trap - 2 3 15" 2 3 15

    if [ -z "$IP_CONFIG" ]
    then
        printf "$ERROR" "Configure IP_CONFIG shell variable"
        return 1
    fi

    # Hack just to allow completion and grab the correct parameter
    local dryrun='cat'
    local options
    options=()
    while [ $1 ]
    do
        case "$1" in
          -f)
            shift
            shift
            ;;
          -n)
            dryrun='sed "s/--execute //"'
            options+=("$1")
            shift
            ;;
          -c)
            local clean=true
            shift
            ;;
          *)
            options+=("$1")
            shift
            ;;
        esac
    done

    [[ -z "$CFG" ]] && local -x CFG="$IP_CONFIG/builder.cfg"

    local currentlocation=`basename $PWD`
    local gitreponame=`git remote -v | sed -nre 's/\s*origin\s*.*(\/)(.*)\s[(]fetch.*/\2/p'`

    if [ -z "$gitreponame" ]
    then
       printf "$ERROR" "Unable to determine git repository; aborting..."
       return
    fi

    echo "Git repository is \"$gitreponame\""

    if [ "$gitreponame" != "integration-platform-config.git" ]
    then
        local -x LOCAL=1
        local -x BUILD_DIR=$PWD
        local -x MVN_DEP_REPO="local::default::file://$HOME/tmp/deploy-local"
        # Place simulator workspace artifacts in a temporary directory.
        local -x WORKSPACE=/tmp/workspace/`mktemp -u XXXXXX`

        local target=`tac $CFG | awk -v gv=$gitreponame '$0 ~ /^scmURL/ && $0 ~ gv { a=$0 } /[[].*[]]/ && a { sub("\\\\[","") ; sub("\\\\]","") ; print $0; exit }'`
        [[ -z "$target" ]] && printf "$ERROR" "Unable to find a matching target" && return
        echo "Building $target in $BUILD_DIR"

        [[ -z "$SETTINGS" ]] && local SETTINGS=$HOME/Work/maven-mead-ip6.xml

        # If repo_group is not already set use mead.
        [[ -z "$REPO_GROUP" ]] && local -x REPO_GROUP=MEAD

        if [[ -z "$MVN_LOCAL_REPO" ]] && [[ -f $SETTINGS ]]
        then
            local -x MVN_LOCAL_REPO=$HOME/`cat $SETTINGS | sed -ne 's/.*\${user.home}\/\(.*\)<\/localRepository>/\1/p'`
            local TAG=`cat $SETTINGS | sed -ne 's/.*repos\/\(.*\)\/latest.*/\1/p'`
        elif [ -z "$MVN_LOCAL_REPO" ]
        then
            echo "\033[49;32;1mWARNING: Unable to find $SETTINGS to find a local repository; defaulting to $WORKSPACE/local-repository\033[0m"
        fi
        if [ "$clean" = "true" ]
        then
            echo "Cleaning..."
            git reset --hard
            rm -rf `find . -name target -type d`
            echo "Done cleaning..."
        fi

        # Hack : make files don't know how to include each other. Sigh.
        cd $NOCHPWD $IP_CONFIG
        # Hack : make files have no clean target right now.
        rm -f "$IP_CONFIG/$target".lastBuild
        rm -rf $WORKSPACE ; mkdir -p $WORKSPACE

        # Check for chain build
        if [ -n "`cat $CFG | grep buildrequires`" ]
        then
            target="-f `cat $CFG | grep makefile | sed 's/.*=//'` BUILDDEPS=\"\" ARTIFACT=$target"
            echo "Chain build support : $target"
        fi

        echo "Using\n\tWorkspace :\t\t$WORKSPACE\n\tREPO_GROUP :\t\t$REPO_GROUP\n\tMVN_LOCAL_REPO :\t$MVN_LOCAL_REPO\n\tMVN_DEP_REPO :\t\t$MVN_DEP_REPO\n\tPOMMANIPEXT :\t\t$POMMANIPEXT\n\tCFG :\t\t\t$CFG\n\tRESUME :\t\t$RESUME"
        make "${options[@]}" `echo $target` | eval $dryrun

        if [ "$CHECK_MEAD" = "1" ] && [[ -f $SETTINGS ]]
        then
            echo "Running MEAD_check_artifact.sh..."
            rm -f $BUILD_DIR/mead_check.log
            ./MEAD_check_artifact.sh $TAG $MVN_LOCAL_REPO > $BUILD_DIR/mead_check.log 2>&1
        fi

        cd $NOCHPWD $BUILD_DIR
    else
        local -x BREW=1
        make "${options[@]}" | eval $dryrun
    fi

    trap - 2 3 15
}


# IP_TOOLING - checkout of make_mead location.
# VMAN_HOME - location of VMAN. This may either be a path to a binary jar or a path to the checkout of built sources.
function vman()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    [[ -z "$VMAN_HOME" ]] && printf "$ERROR" "Set VMAN_HOME" && return 1
    [[ -f "$VMAN_HOME" ]] && local JAR=$VMAN_HOME || local JAR=$VMAN_HOME/target/vman.jar

    [[ "$1" = "-clean" ]] && echo "Cleaning for vman..." && rm -rf `find . -type d -name target` && rm -rf `find . -name vman-workspace` && rgit reset --hard && shift

    if [ -n "$IP_TOOLING" ]
    then
        local KEYSTORE=$IP_TOOLING/jssecacerts
        local CERT="-Djavax.net.ssl.trustStore=${KEYSTORE} -Djavax.net.ssl.trustStorePassword=changeit -Djavax.net.ssl.trustStoreType=jks -Djavax.net.ssl.keyStore=${KEYSTORE} -Djavax.net.ssl.keyStorePassword=changeit -Djavax.net.ssl.keyStoreType=jks"
    else
        echo "IP_TOOLING not set; not setting jssecacerts"
    fi
    if [[ "$*" != *--version-suffix* ]] && [[ "$*" != *-s* ]]
    then
        echo "\033[49;32;1mWARNING: Recommend explicitly passing version-suffix on command line\033[0m"
    fi

    # JAVA_OPTS allow dynamic configuration of the VM for e.g. debugging etc.
    java $JAVA_OPTS `echo $CERT` -jar $JAR "$@"

    if [ "$?" = "0" ]
    then
        echo ""
        echo "For modified dependencies either:"
        echo "\033[49;32;1m    less vman-workspace/reports/modified-dependencies.md\033[0m"
        echo "or if https://addons.mozilla.org/en-US/firefox/addon/markdown-viewer is installed:"
        echo "\033[49;32;1m    firefox -new-tab vman-workspace/reports/modified-dependencies.md\033[0m"
        echo "\033[49;32;1m    firefox -new-tab vman-workspace/reports/mapped-dependencies.md\033[0m"
        echo "\033[49;32;1m    firefox -new-tab vman-workspace/reports/unmapped-dependencies.md\033[0m"
    else
        echo "" ; echo "Errors running vman."
    fi
}

#
# This script is sourced from
# https://community.jboss.org/blogs/stuartdouglas/2011/09/06/merging-github-pull-requests?_sscc=t
# and is designed to handle pull requests from github without leading to merges
# in the history (it does a rebase instead.
function mergePullRequest()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    if [ "$1" = "-r" ]
    then
        shift
        local cmd="git fetch $1 "
        shift
    else
        local cmd="git fetch origin "
    fi
    local branch=`git rev-parse --abbrev-ref HEAD`
    local tmpbranch=`uuidgen`

    for var in "$@"
    do
        cmd="$cmd pull/$var/head:pullRequest$var"
    done

    echo -e "\033[49;32;1m### -> Will merge pull request onto $branch\033[0m"

    echo "Running: '$cmd"
    eval $cmd

    for var in "$@"
    do
        git checkout pullRequest$var
        [[ "$?" != "0" ]] && printf "$ERROR" "Error checking out branch; aborting..." && return 1
        git lg -n 1
        local original=`git log -1 --pretty="%H"`

        git checkout -b $tmpbranch
        echo "### Rebasing to $branch"
        git rebase $branch
        [[ "$?" != "0" ]] && printf "$ERROR" "Error rebasing $branch; aborting..." && return 1
        git lg -n 1
        local new=`git log -1 --pretty="%H"`

        if [ "$original" != "$new" ]
        then
            echo "\033[49;32;1mGIT SHA do not match ; unable to rebase ; switching to merge\033[0m"
            git checkout $branch
            git merge --no-edit -m "Merge pull request #$var" --no-ff pullRequest$var
        else
            git checkout $branch
            [[ "$?" != "0" ]] && printf "$ERROR" "Error checking out branch; aborting..." && return 1
            echo "### Merging pullRequest$var"
            git merge $tmpbranch
            git lg -n 1
        fi
        [[ "$?" != "0" ]] && printf "$ERROR" "Error merging pull request; aborting..." && return 1
        git branch -D pullRequest$var $tmpbranch
        [[ "$?" != "0" ]] && printf "$ERROR" "Error deleting branch; aborting..." && return 1
    done
    echo -e "\033[49;32;1mFinished\033[0m"
}


# Information sourced from
#  http://git-scm.com/book/ch8-2.html
#  http://dereenigne.org/git/git-svn-mirror
# Takes project source URL [target-dir]
gitsvnclone()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    [[ -z "$1" ]] && printf "$ERROR" "No source URL specified." && return 1
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"

    TARGETDIR=`basename $1`
    [[ -n "$2" ]] && TARGETDIR=$2

    [[ -d $TARGETDIR ]] && printf "$ERROR" "Target directory already exists" && return 1

    git svn --stdlayout --branches="branches/*/*" --tags="tags/*/*" clone $1 $TARGETDIR

    echo "Resetting tags and branches"
    cd  $NOCHPWD $TARGETDIR
    git for-each-ref refs/remotes/tags | cut -d / -f 4- | grep -v @ | while read tagname; do echo "Processing $tagname"; git tag "$tagname" "tags/$tagname"; git branch -r -d "tags/$tagname"; done
    echo "Done tags; now branches..."
    git for-each-ref refs/remotes | cut -d / -f 3- | grep -v @ | while read branchname; do echo "Processing $tagname"; git branch "$branchname" "refs/remotes/$branchname"; git branch -r -d "$branchname"; done
    echo "Completed cloning svn repository."
    echo ""
    echo "Now add a remote (git remote add gitapp ....)"
    echo "and push the tags: git push --tags gitapp"
}


#
# Runs get-maven-artifacts and import-maven.
# Optional parameters:
#    --continue  Continue on erorr
#    --tag <tag> to import into.
#    --noimport - Don't do any importing
#    --owner <name> owner name to user (normally defaults to $USER)
#    --save <dir> copy downloaded dirs to dir
#    --install <repo> optionally install the artifact to the specified local repository.
#                     This saves having to wait for repository regeneration.
#    --release <value> increment release version on import. Passed directory to import-maven
#    --repo <value> specify an extra repository to search. Passed directory to get-maven-artifacts
# Then takes e.g.
# org.apache.derby:derby-project:pom:10.8.2.2 org.eclipse.jetty:jetty-util:jar:7.6.3 ....
#
# If you have a result from the check artifacts this sed script can help:
# get-and-import <flags> `cat mead_check.log | grep MISSING | grep -v -- -redhat- | sed 's/MISSING: \(.*\) FROM:.*/\1/g' | tr '\n' ' '`
#
get-and-import()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local owner=$USER
    local cwd=$PWD
    local continue="return 1"
    [[ -n $ZSH_VERSION ]] && local NOCHPWD="-q"

    cleanup()
    {
        cd $NOCHPWD $cwd
        rm -rf $ddir
    }

    which get-maven-artifacts >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Mike Bonnet's get-maven-artifacts and import-maven must be in the path. Aborting." && return 1
    which mvn >& /dev/null
    [[ "$?" != "0" ]] && printf "$ERROR" "Error : Maven not configured." && return 1

    while [ -n "$1" ]
    do
        case "$1" in
          --continue)
            local continue=" echo -e \"\033[49;35;1mContinuing...\033[0m\" && continue"
            shift
            ;;
          --tag)
            shift
            local TAG="--tag=$1"
            shift
            ;;
          --owner)
            shift
            local owner=$1
            shift
            ;;
          --save)
            shift
            local SAVE=$1
            shift
            ;;
          --install)
            shift
            local INSTALL=$1
            shift
            ;;
          --noimport)
            local NOIMPORT=true
            shift
            ;;
          --release)
            shift
            local RELEASE="--release=$1"
            shift
            ;;
          --repo)
            shift
            local REPO="--repo=$1"
            shift
            ;;
          *)
            break;
        esac
    done

    [[ -z "$1" ]] && "Package to import is not set" && return 1

    while [ -n "$1" ]
    do
        # Strip off any comma/trailing colon if we cut and pasted from a maven log.
        local package=`echo ${1%:} | tr -d ','`
        local ddir=$PWD/`mktemp -d tmp.XXXXXX`
        echo -n "\033[49;32;1mImporting package $package "
        [[ -n "$owner" ]] && echo -n "with owner $owner "
        [[ -n "$TAG" ]] && echo -n "into tag ${TAG#--tag } "
        echo "to dir $ddir\033[0m"

        cd $NOCHPWD $ddir
        get-maven-artifacts $REPO $package
        [[ "$?" != "0" ]] && echo "Error obtaining packages" && shift && cleanup && eval $continue
        echo "Downloaded artifacts..."
        if [ -n "$INSTALL" ]
        then
            local pom=`find . -name "*.pom"`
            local jar=`find . -name "*.[a-z]ar" | sort | head -1`
            local x=""
            local tp=""

            if [ -z "$jar" ]
            then
                echo "Running mvn -Dmaven.repo.local=$INSTALL -DpomFile=$pom -Dfile=$pom install:install-file"
                # http://austinmatzko.com/2008/04/26/sed-multi-line-search-and-replace/
                TP=`dirname $(mvn -Dmaven.repo.local=$INSTALL -DpomFile=$pom -Dfile=$pom install:install-file | sed -n '
                # if the first line copy the pattern to the hold buffer
                1h
                # if not the first line then append the pattern to the hold buffer
                1!H
                # if the last line then ...
                $ {
                  g
                  s/.*to\(.*pom\).*/\1/g
                  p
                  }
                ')`
            else
                echo "Running mvn -q -Dpackaging=jar -Dmaven.repo.local=$INSTALL -DpomFile=$pom -Dfile=$jar install:install-file"
                # http://austinmatzko.com/2008/04/26/sed-multi-line-search-and-replace/
                TP=`dirname $(mvn -Dpackaging=jar -Dmaven.repo.local=$INSTALL -DpomFile=$pom -Dfile=$jar install:install-file | sed -n '
                # if the first line copy the pattern to the hold buffer
                1h
                # if not the first line then append the pattern to the hold buffer
                1!H
                # if the last line then ...
                $ {
                  g
                  s/.*to\(.*pom\).*/\1/g
                  p
                  }
                ')`

                # Now install any other jar files (e.g. sources, javadoc)
                for x in `find . -name \*.[a-z]ar | grep -v $jar`
                do
                    local classifier=`echo $x | sed -e '/.*-[0-9].*-\(.*\).[a-z]ar/!d;s//\1/' `
                    local packaging=`echo $x | sed 's/.*\.\([a-z]ar\)/\1/'`

                    echo "Running mvn -Dpackaging=$packaging -Dmaven.repo.local=$INSTALL -DpomFile=$pom -Dfile=$x -Dclassifier=$classifier install:install-file"
                    mvn -q -Dpackaging=$packaging -Dmaven.repo.local=$INSTALL -DpomFile=$pom -Dfile=$x -Dclassifier=$classifier install:install-file
                done
            fi
            if [ "$NOIMPORT" = "true" ]
            then
                echo "\033[49;33;1mCreating marker file in $TP/.noimport\033[0m"
                touch $TP/.noimport
            else
                /bin/rm -f $TP/.noimport
            fi
        fi
        if [ "$NOIMPORT" != "true" ]
        then
            import-maven --owner=$owner $RELEASE `echo $TAG` `/bin/ls -1 $ddir`
            [[ "$?" != "0" ]] && echo "Error importing packages" && shift && cleanup && eval $continue
        fi

        if [ -n "$SAVE" ]
        then
            /bin/cp -f $ddir/* $SAVE
        fi

        shift
        cleanup
    done
    echo -e "\033[49;32;1mFinished\033[0m"
}



#
# Quick hack to take a POM file and print all of its GAVs out.
#
function printBOMGAs
{
    which mvn >& /dev/null
    [[ "$?" != 0 ]] && printf "$ERROR" "Configure Maven" && return 1

    local WORKDIR=`mktemp -p /tmp -d XXXX --suffix=bomanalysis`
    # Default for my purposes for now...
    local POM="org.jboss.fuse.bom:jboss-fuse-parent:6.2.1.redhat-032"
    # Could be a file reference e.g. file://`pwd`/cli/target/pom-manipulation-ext-1.8.jar
    local PME="http://central.maven.org/maven2/org/commonjava/maven/ext/pom-manipulation-cli/1.8/pom-manipulation-cli-1.8.jar"

    while [ -n "$1" ]
    do
        case "$1" in
          --workdir)
            shift
            local WORKDIR=$1
            shift
            ;;
          --pom)
            shift
            local POM=$1
            shift
            ;;
          --pme)
            shift
            local PME=$1
            shift
            ;;
          --help)
            echo "Usage is $0 [--workdir <dir>] [--pom <e.g. org.jboss.fuse.bom:jboss-fuse-parent:6.2.1.redhat-032>] [--pme <PME location>]"
            return 1
            ;;
          *)
            break;
        esac
    done

    cd $WORKDIR
    echo "Using workdir `pwd`"

    # No need to clone the repo ; just use the deployed version
    # git clone --depth 1 --branch fuseenterprise-6.2.1.redhat-032 git@github.com:jboss-fuse/fuse.git
    [[ -f pom.xml ]] && echo "warning : pom.xml already exists in this directory. Clean up first." && return 1
    mvn -q org.apache.maven.plugins:maven-dependency-plugin:2.10:get \
        -DremoteRepositories=https://origin-repository.jboss.org/nexus/content/groups/ea,http://maven.repository.redhat.com/nexus/content/groups/product-earlyaccess \
        -Dartifact=$POM:pom \
        -Ddest=pom.xml
    [[ "$?" != 0 ]] && printf "$ERROR" "Error downloading" && return 1
    sed -i 's/<module.*//g' pom.xml
    sed -i 's/<\/module.*//g' pom.xml
    echo "Downloaded remote pom file; now running effective:pom"

    mvn -q help:effective-pom -Doutput=effective.pom
    [[ "$?" != 0 ]] && printf "$ERROR" "Error creating effective pom" && return 1

    /bin/mv -f pom.xml original-pom.xml
    /bin/mv -f effective.pom pom.xml

    echo "Renaming effective.pom -> pom.xml and running analysis..."
    curl -s -o`echo $PME | sed 's/.*\///g'` $PME
    /bin/rm -f allgavs.log allnonrhga.log
    java -jar `echo $PME | sed 's/.*\///g'` -p | egrep -v '(Maven-Manipulation-Extension|Found the following dependencies)' > allgavs.log 2>&1


    echo "GAV count is `cat allgavs.log | wc -l`"
    echo "Non redhat GAV count is `cat allgavs.log | grep -v redhat | wc -l`"
    cat allgavs.log | grep -v redhat | awk '{print $1}' | sed -E 's/(.*):[a-z]+:[0-9]+.*/\1/g' | sort | uniq > allnonrhga.log
    echo "Non redhat GA count is `cat allnonrhga.log | wc -l`"

    # java -jar /home/rnc/Work/PME/pom-manipulation-ext/cli/target/pom-manipulation-cli-1.8-SNAPSHOT.jar -p | egrep -v redhat | awk '{print $1}' | sed -E 's/(.*):[a-z]+:[0-9]+.*/\1/g' | sort | uniq > fabric8nonrhga.log
    # awk 'NR==FNR{a[$0];next} !($0 in a)' /tmp/fusenonrhga.log fabricnonrhga
    #cd ..
    #rm -rf $WORKDIR
}


# Same as list-tag-inheritance but trim off excess depth.
function blt()
{
    brew list-tag-inheritance $1 | sed -e 's/  │          .*/  │       [...tag continues...]/g' -e 's/              .*/              [...tag continues...]/g' | uniq | egrep '...tag continues...|$'
}
